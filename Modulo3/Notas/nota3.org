* Fundamentos de Programación en Python: Módulo 3

** Tomando decisiones en Python

Un programador escribe un programa y el programa hace preguntas.Afortunadamente, las computadoras solo conocen dos tipos de respuestas:
    + Si, es cierto.
    + No, esto es falso.
Para hacer preguntas, Python utiliza un conjunto de operadores muy especiales.
*** Operadores de Comparación
**** El operador igual a (==)
El operador == (igual a) compara los valores de dos operandos. Si son iguales, el resultado de la comparación es True. Si no son iguales, el resultado de la comparación es False.
**** El operador no es igual a (!=)
El operador != (no es igual a) también compara los valores de dos operandos. Aquí está la diferencia: si son iguales, el resultado de la comparación es False. Si no son iguales, el resultado de la comparación es True.
**** Mayor que
También se puede hacer una pregunta de comparación usando el operador > (mayor que).


**** Mayor o igual que
El operador mayor que tiene otra variante especial, una variante no estricta, pero se denota de manera diferente que la notación aritmética clásica: >= (mayor o igual que).


**** Menor o igual que
Como probablemente ya hayas adivinado, los operadores utilizados en este caso son: El operador < (menor que) y su hermano no estricto: <= (menor o igual que).
*** Tabla de Prioridades
| **Prioridad** | **Operador** |         |
|---------------+--------------+---------|
|             1 | +,-          | unario  |
|             2 | **           |         |
|             3 | *,/,%        |         |
|             4 | +,-          | binario |
|             5 | <,<=,>,>=    |         |
|             6 | ==, !=       |         |
*** Ejercicios
+ [Preguntas y respuestas]()

*** Condiciones y ejecución condicional

Se debe tener un mecanismo que le permita hacer algo **si se cumple una condición, y no hacerlo si no se cumple**.

Python ofrece una instrucción especial. Debido a su naturaleza y su aplicación, se denomina instrucción condicional (o declaración condicional).

+ Ejecución condicional: La declaración if
  #+BEGIN_SRC python
  if cierto_o_no:
    hacer_esto_si_cierto
  #+END_SRC
  + ¿Cómo funciona esta expresión?
    + Si la expresión cierto_o_no representa la verdad (es decir, su valor no es igual a cero),la(s) declaración(es) con sangría se ejecutará.
    + Si la expresión cierto_o_no no representa la verdad (es decir, su valor es igual a cero), las declaraciones con sangría se omitirá , y la siguiente instrucción ejecutada será la siguiente al nivel de la sangría original.
+ Ejecución condicional: la declaración if-else
  *Si el clima es bueno, saldremos a caminar, de lo contrario, iremos al cine.*

  Ahora sabemos lo que haremos si se cumplen las condiciones , y sabemos lo que haremos si no todo sale como queremos . En otras palabras, tenemos un "Plan B".

  Python nos permite expresar dichos planes alternativos. Esto se hace con una segunda forma, ligeramente mas compleja, de la declaración condicional, la declaración if-else :
  #+BEGIN_SRC python
  if condición_true_or_false:
      ejecuta_si_condición_true
  else:
      ejecuta_si_condición_false
  #+END_SRC

    + La ejecución de if-else es la siguiente:
       + Si la condición se evalúa como Verdadero (su valor no es igual a cero), la instrucción ejecuta_si_condición_true se ejecuta, y la declaración condicional llega a su fin.
       + Si la condición se evalúa como Falso (es igual a cero), la instrucción ejecuta_si_condición_false se ejecuta, y la declaración condicional llega a su fin.
    + Declaraciones if-else anidadas
      Primero, considera el caso donde la instrucción colocada después del if  es otro if.

      #+BEGIN_SRC
      if climaEsBueno:
           if encontramosBuenRestaurante:
              almorzar()
           else:
              comerSandwich()
      else:
           if hayBoletosDisponibles:
              irAlCine()
           else:
              irDeCompras()
       #END_SRC
+ La declaración elif
  El segundo caso especial presenta otra nueva palabra clave de Python: elif. Como probablemente sospechas, es una forma más corta de else-if.

  elif se usa para verificar más de una condición, y para detener cuando se encuentra la primera declaración verdadera.
  #+BEGIN_SRC python
  if climaBueno:
      iraCaminar()
  elif hayBoletosDisponibles:
      IralCine()
  elif mesasLibres:
      almorzar()
  else:
      jugarAjedrezEnCasa()
  #+END_SRC
  La forma de ensamblar las siguientes declaraciones if-elif-else a veces se denomina **cascada**.
  Se debe prestar atención adicional a este caso:

   + No debes usar else sin un if precedente.
   + Else siempre es la última rama de la cascada , independientemente de si has usado elif o no.
   + Else es una parte opcional de la cascada, y puede omitirse.
   + Si hay una rama else en la cascada, solo se ejecuta una de todas las ramas.
   + Si no hay una rama else, es posible que no se ejecute ninguna de las opciones disponibles.

*** Ejercicios
+ [Preguntas y Respuestas]()
+ [Operadores de comparación y ejcucion de Condicional]()
+ [La instrucción if Else]()
+ [If-Elif-Else]()
** Puntos Clave
1. Los operadores de comparación (o también denominados relacionales) se utilizan para comparar valores. La siguiente tabla ilustra cómo funcionan los operadores de comparación, asumiendo que x=0, y=1 y z=0:
| **Operador** | **Descripción**                                                                                                           | **Ejemplo**                     |
|--------------+---------------------------------------------------------------------------------------------------------------------------+---------------------------------|
| ==           | Devuelve si los valores de los operandos son iguales, y False de lo contrario.                                            | x == y # False, x == z # True   |
| !=           | Devuelve True si los valores de los operandos no son iguales, y False de lo contrario.                                    | x != y # True,   x != z # False |
| >            | DevuelveTrue si el valor del operando izquierdo es mayor que el valor del operando derecho, y False de lo contrario.      | x > y # False,y > z # True      |
| <            | Devuelve True si el valor del operando izquierdo es menor que el valor del operando derecho, y False de lo contrario.     | x < y # True y < z # False      |
| >=           | Devuelve True si el valor del operando izquierdo es mayor o igual al valor del operando derecho, y False de lo contrario. |                                 |
| <=           | Devuelve True si el valor del operando izquierdo es menor o igual al valor del operando derecho, y False de lo contrario. |                                 |
2. Cuando desea ejecutar algún código solo si se cumple una determinada condición, puede usar una declaración condicional:
   + Una única declaración if, por ejemplo:
     #+BEGIN_SRC python
     x = 10

     if x == 10: # condición
     print("x es igual a 10") # ejecutado si la condición es verdadera
     #+END_SRC
   + Una serie de declaraciones if, por ejemplo:
     #+BEGIN_SRC python
     x = 10

     if x > 5: # condición uno
        print("x es mayor que 5") # ejecutado si la condición uno es verdadera

     if x <10: # condición dos
        print("x es menor que 10") # ejecutado si la condición dos es verdadera

     if x == 10: # condición tres
        print("x es igual a 10") # ejecutado si la condición tres es verdadera
    #+END_SRC
    Cada declaración if se prueba por separado.
   + Una declaración de if-else, por ejemplo:
     #+BEGIN_SRC python
     x = 10

     if x < 10: # condición
        print ("x es menor que 10") # ejecutado si la condición es Verdadera

     else:
        print ("x es mayor o igual a 10") # ejecutado si la condición es False
    #+END_SRC
   + Una serie de declaraciones if seguidas de un else, por ejemplo:
     #+BEGIN_SRC python
     x = 10

     if x > 5: # Verdadero
        print("x > 5")

     if x > 8: # Verdadero
        print("x > 8")

     if x > 10: # Falso
        print("x > 10")

     else:
        print("Se ejecutará el else")
    #+END_SRC

     Cada if se prueba por separado. El cuerpo de else se ejecuta si el último if es False.
   + La declaración  if-elif-else, por ejemplo:
     #+BEGIN_SRC  python
     x = 10

     if  x == 10: # Verdadero
        print("x == 10")

     if x > 15: # Falso
        print("x > 15")

     elif x > 10: # Falso
        print("x > 10")

     elif x > 5: # Verdadero
        print("x > 5")

     else:
        print("No se ejecutará el else")
        #+END_SRC

        Si la condición para if es False, el programa verifica las condiciones de los bloques elif posteriores: el primer elif que sea True es el que se ejecuta. Si todas las condiciones son False, se ejecutará el bloque else.

   + Declaraciones condicionales anidadas, ejemplo:
     #+BEGIN_SRC python
     x = 10

     if x > 5: # Verdadero
        if x == 6: # Falso
            print("anidado: x == 6")
     elif x == 10: # Verdadero
           print("anidado: x == 10")
     else:
           print("anidado: else")
     else:
        print("else")
    #+END_SRC

** Ciclos en Python
#+BEGIN_CENTER
mientras haya algo que hacer hazlo
#+END_CENTER
*** While
En Python, un ciclo se puede representar de la siguiente manera:
#+BEGIN_SRC python
while expresión_condicional:
    instrucción
#+END_SRC
while repite la ejecución siempre que la condición se evalúe como True.

Ahora, es importante recordar que:

+ Si deseas ejecutar más de una declaración dentro de un while, debes (como con if) poner sangría a todas las instrucciones de la misma manera.
+ Una instrucción o conjunto de instrucciones ejecutadas dentro del while se llama el cuerpo del ciclo.
+ Si la condición es False (igual a cero) tan pronto como se compruebe por primera vez, el cuerpo no se ejecuta ni una sola vez (ten en cuenta la analogía de no tener que hacer nada si no hay nada que hacer).
+ El cuerpo debe poder cambiar el valor de la condición, porque si la condición es True al principio, el cuerpo podría funcionar continuamente hasta el infinito. Observa que hacer una cosa generalmente disminuye la cantidad de cosas por hacer.
**** Un bucle o ciclo infinito
Un ciclo infinito, también denominado ciclo sin fin, es una secuencia de instrucciones en un programa que se repite indefinidamente (ciclo sin fin).
#+BEGIN_SRC python
while True:
    print("Estoy atrapado dentro de un ciclo")
#+END_SRC


**EJERCICIO**
[Adivina  el número secreto]()

*** For
Otro tipo de ciclo disponible en Python proviene de la observación de que a veces es más importante contar los "giros o vueltas" del ciclo que verificar las condiciones. El ciclo for está diseñado para realizar tareas más complicadas, puede "explorar" grandes colecciones de datos elemento por elemento.
#+BEGIN_SRC python
 for i in range (100):
    #hacer algo()
    pass
#+END_SRC

+ La palabra reservada for abre el ciclo for; nota - No hay condición después de eso; no tienes que pensar en las condiciones, ya que se verifican internamente, sin ninguna intervención.
+ Cualquier variable después de la palabra reservada for es la **variable de control del ciclo**; cuenta los giros del ciclo y lo hace automáticamente.
+ La palabra reservada in introduce un elemento de sintaxis que describe el rango de valores posibles que se asignan a la variable de control.
+ La función range() (esta es una función muy especial) es responsable de generar todos los valores deseados de la variable de control; en nuestro ejemplo, la función creará (incluso podemos decir que alimentará el ciclo con) valores subsiguientes del siguiente conjunto: 0, 1, 2 .. 97, 98, 99; nota: en este caso, la función range() comienza su trabajo desde 0 y lo finaliza un paso (un número entero) antes del valor de su argumento.
+ Nota la palabra clave pass dentro del cuerpo del ciclo - no hace nada en absoluto; es una instrucción vacía : la colocamos aquí porque la sintaxis del ciclo for exige al menos una instrucción dentro del cuerpo (por cierto, if, elif, else y while expresan lo mismo).

***** EJEMPLOS

#+BEGIN_SRC python
for i in range(2, 8, 3):
    print("El valor de i es actualmente", i)
#NO IMPRIME NADA
for i in range(1, 1):
    print("El valor de i es actualmente", i)

#PRIMERAS POTENCIAS DE DOS
pow = 1
for exp in range(16):
    print ("2 a la potencia de", exp, "es", pow)
    pow * = 2
#+END_SRC

***** EJERCICIOS

+ [Aspectos fundamentales del ciclo for: el conteo]()

*** Las declaraciones break y continue
Podrías enfrentar las siguientes opciones:
+ Parece que no es necesario continuar el ciclo en su totalidad; se debe abstener
  de seguir ejecutando el cuerpo del ciclo e ir más allá.
+ Parece que necesitas comenzar el siguiente giro del ciclo sin completar la ejecución del turno actual.

Python proporciona dos instrucciones especiales para la implementación de estas dos tareas.

**** Nota:
Tales adiciones, que no mejoran el poder expresivo del lenguaje, sino que solo simplifican el trabajo del desarrollador, a veces se denominan dulces sintácticos o azúcar sintáctica.

Estas dos instrucciones son:

+ Break: Sale del ciclo inmediatamente, e incondicionalmente termina la operación del ciclo; el programa comienza a ejecutar la instrucción más cercana después del cuerpo del ciclo.
+ Continue: Se comporta como si el programa hubiera llegado repentinamente al final del cuerpo; el siguiente turno se inicia y la expresión de condición se prueba de inmediato.
**** EJERCICIO
+ [Atascado en un ciclo]()
+ [El Feo Devorador de Vocales]()
+ [El Bonito Devorador de Vocales]()

*** El while y la opción else
los ciclos también pueden tener la rama else, como los if.

La rama else del ciclo siempre se ejecuta una vez, independientemente de si el ciclo ha entrado o no en su cuerpo .

#+BEGIN_SRC python
i = 5
while i < 5:
    print(i)
    i += 1
else:
    print("else:", i)

i = 111
for i in range(2, 1):
    print(i)
else:
    print("else:", i)
    #+END_SRC
    Nota: si la variable de control no existe antes de que comience el ciclo, no existirá cuando la ejecución llegue a la rama else

***** EJERCICIOS
+ [WHILE]()
+ [ Hipótesis de Collatz]()
** Puntos Clave
1. Hay dos tipos de ciclos en Python: while y for:
   + El ciclo while ejecuta una sentencia o un conjunto de declaraciones siempre que una condición booleana especificada sea verdadera, por ejemplo:
     #+BEGIN_SRC python
     # Ejemplo 1
     while True:
         print("Atascado en un ciclo infinito")

     # Ejemplo 2
    contador = 5
    while contador > 2:
        print(contador)
        contador -= 1
     #+END_SRC
  + El ciclo for ejecuta un conjunto de sentencias muchas veces; se usa para iterar sobre una secuencia (por ejemplo, una lista, un diccionario, una tupla o un conjunto; pronto aprenderás sobre ellos) u otros objetos que son iterables (por ejemplo, cadenas). Puedes usar el ciclo for para iterar sobre una secuencia de números usando la función incorporada range. Mira los ejemplos a continuación:
    #+BEGIN_SRC python
# Ejemplo 1
palabra = "Python"
for letter in palabra:
    print(letter, fin = "*")

# Ejemplo 2
for i in range(1, 10):
    if i % 2 == 0:
        print(i)
        #+END_SRC
2. Puedes usar las sentencias break y continue para cambiar el flujo de un ciclo:
   + Utiliza break para salir de un ciclo, por ejemplo:
     #+BEGIN_SRC python
     texto = "OpenEDG Python Institute"
     for letter in texto:
        if letter == "P":
            break
        print(letter, end= "")
    #+END_SRC
   + Utiliza continue para omitir la iteración actual, y continuar con la siguiente iteración, por ejemplo:
     #+BEGIN_SRC python
     text = "pyxpyxpyx"
     for letter in text:
        if letter == "x":
            continue
        print(letter, end= "")

** Operaciones lógicas y de bits en Python
*** Operadores lógicos
+ and
   Un operador de conjunción lógica en Python es la palabra y. Es un operador binario con una prioridad inferior a la expresada por los operadores de comparación.
   #+BEGIN_SRC python
   contador > 0 and valor == 100
   #+END_SRC
   El resultado proporcionado por el operador and se puede determinar sobre la base de la tabla de verdad.
   | A | B | A and B |
   |---+---+---------|
   | 0 | 0 |       0 |
   | 0 | 1 |       0 |
   | 1 | 0 |       0 |
   | 1 | 1 |       1 |
+ or
  Un operador de disyunción es la palabra or. Es un operador binario con una prioridad más baja que and (al igual que + en comparación con *). Su tabla de verdad es la siguiente:
  | A | B | A or B |
  |---+---+--------|
  | 0 | 0 |      0 |
  | 0 | 1 |      1 |
  | 1 | 0 |      1 |
  | 1 | 1 |      1 |
+ not
  Es un operador unario que realiza una negación lógica. Su funcionamiento es simple: convierte la verdad en falso y lo falso en verdad.


*** Operadores bitwise
Permiten manipular bits de datos individuales.
Cubren todas las operaciones que mencionamos anteriormente en el contexto lógico, y un operador adicional. Este es el operador xor (como en o exclusivo ), y se denota como ^ (signo de intercalación).

Aquí están todos ellos:

+  &  (ampersand) - conjunción a nivel de bits.
+  |  (barra vertical) - disyunción a nivel de bits.
+  ~  (tilde) - negación a nivel de bits.
+  ^  (signo de intercalación) - exclusivo a nivel de bits o (xor).
| A | B | B&A | A\  B | A^B |
|---+---+-----+-------+-----|
| 0 | 0 |   0 |     0 |   0 |
| 0 | 1 |   0 |     1 |   1 |
| 1 | 0 |   0 |     1 |   1 |
| 1 | 1 |   1 |     1 |   0 |
Hagámoslo más fácil:

+  &  requieres exactamente dos  1  s para proporcionar  1  como resultado.
+  |  requiere al menos un  1  para proporcionar  1  como resultado.
+  ^  requiere exactamente un  1  para proporcionar  1  como resultado.
